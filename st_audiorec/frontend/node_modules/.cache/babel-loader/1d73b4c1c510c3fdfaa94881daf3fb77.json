{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar f64 = new Float64Array(1);\nvar u32 = new Uint32Array(f64.buffer);\n/**\n * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29\n * @param h {number} the uint16 to convert\n * @private\n * @ignore\n */\n\nexport function uint16ToFloat64(h) {\n  var expo = (h & 0x7C00) >> 10;\n  var sigf = (h & 0x03FF) / 1024;\n  var sign = Math.pow(-1, (h & 0x8000) >> 15);\n\n  switch (expo) {\n    case 0x1F:\n      return sign * (sigf ? NaN : 1 / 0);\n\n    case 0x00:\n      return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n  }\n\n  return sign * Math.pow(2, expo - 15) * (1 + sigf);\n}\n/**\n * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * @param d {number} The float64 to convert\n * @private\n * @ignore\n */\n\nexport function float64ToUint16(d) {\n  if (d !== d) {\n    return 0x7E00;\n  } // NaN\n\n\n  f64[0] = d; // Magic numbers:\n  // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n  // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n  // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n\n  var sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n  var expo = u32[1] & 0x7ff00000,\n      sigf = 0x0000;\n\n  if (expo >= 0x40f00000) {\n    //\n    // If exponent overflowed, the float16 is either NaN or Infinity.\n    // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n    //\n    // Magic numbers:\n    // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n    // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n    //\n    // returns:\n    // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n    // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n    // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n    // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n    //\n    // If mantissa is greater than 23 bits, set to +Infinity like numpy\n    if (u32[0] > 0) {\n      expo = 0x7C00;\n    } else {\n      expo = (expo & 0x7C000000) >> 16;\n      sigf = (u32[1] & 0x000fffff) >> 10;\n    }\n  } else if (expo <= 0x3f000000) {\n    //\n    // If exponent underflowed, the float is either signed zero or subnormal.\n    //\n    // Magic numbers:\n    // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n    //\n    sigf = 0x100000 + (u32[1] & 0x000fffff);\n    sigf = 0x100000 + (sigf << (expo >> 20) - 998) >> 21;\n    expo = 0;\n  } else {\n    //\n    // No overflow or underflow, rebase the exponent and round the mantissa\n    // Magic numbers:\n    // 0x200 = 00000010 00000000 -- masks off the 10th bit\n    //\n    // Ensure the first mantissa bit (the 10th one) is 1 and round\n    expo = expo - 0x3f000000 >> 10;\n    sigf = (u32[1] & 0x000fffff) + 0x200 >> 10;\n  }\n\n  return sign | expo | sigf & 0xFFFF;\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,GAAG,GAAG,IAAIC,YAAJ,CAAiB,CAAjB,CAAZ;AACA,IAAMC,GAAG,GAAG,IAAIC,WAAJ,CAAgBH,GAAG,CAACI,MAApB,CAAZ;AAEA;;;;;;;;AAOA,OAAM,SAAUC,eAAV,CAA0BC,CAA1B,EAAmC;AACrC,MAAIC,IAAI,GAAG,CAACD,CAAC,GAAG,MAAL,KAAgB,EAA3B;AACA,MAAIE,IAAI,GAAG,CAACF,CAAC,GAAG,MAAL,IAAe,IAA1B;AACA,MAAIG,IAAI,YAAI,CAAC,CAAL,EAAY,CAACH,CAAC,GAAG,MAAL,KAAgB,EAA5B,CAAR;;AACA,UAAQC,IAAR;AACI,SAAK,IAAL;AAAW,aAAOE,IAAI,IAAID,IAAI,GAAGE,GAAH,GAAS,IAAI,CAArB,CAAX;;AACX,SAAK,IAAL;AAAW,aAAOD,IAAI,IAAID,IAAI,GAAG,iBAAiBA,IAApB,GAA2B,CAAnC,CAAX;AAFf;;AAIA,SAAOC,IAAI,YAAI,CAAJ,EAAUF,IAAI,GAAG,EAAjB,CAAJ,IAA6B,IAAIC,IAAjC,CAAP;AACH;AAED;;;;;;;;AAOA,OAAM,SAAUG,eAAV,CAA0BC,CAA1B,EAAmC;AAErC,MAAIA,CAAC,KAAKA,CAAV,EAAa;AAAE,WAAO,MAAP;AAAgB,GAFM,CAEL;;;AAEhCZ,KAAG,CAAC,CAAD,CAAH,GAASY,CAAT,CAJqC,CAMrC;AACA;AACA;AACA;;AAEA,MAAIH,IAAI,GAAG,CAACP,GAAG,CAAC,CAAD,CAAH,GAAS,UAAV,KAAyB,EAAzB,GAA8B,MAAzC;AACA,MAAIK,IAAI,GAAIL,GAAG,CAAC,CAAD,CAAH,GAAS,UAArB;AAAA,MAAkCM,IAAI,GAAG,MAAzC;;AAEA,MAAID,IAAI,IAAI,UAAZ,EAAwB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIL,GAAG,CAAC,CAAD,CAAH,GAAS,CAAb,EAAgB;AACZK,UAAI,GAAG,MAAP;AACH,KAFD,MAEO;AACHA,UAAI,GAAG,CAACA,IAAI,GAAG,UAAR,KAAuB,EAA9B;AACAC,UAAI,GAAG,CAACN,GAAG,CAAC,CAAD,CAAH,GAAS,UAAV,KAAyB,EAAhC;AACH;AACJ,GAtBD,MAsBO,IAAIK,IAAI,IAAI,UAAZ,EAAwB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACAC,QAAI,GAAG,YAAYN,GAAG,CAAC,CAAD,CAAH,GAAS,UAArB,CAAP;AACAM,QAAI,GAAG,YAAYA,IAAI,IAAK,CAACD,IAAI,IAAI,EAAT,IAAe,GAApC,KAA6C,EAApD;AACAA,QAAI,GAAG,CAAP;AACH,GAVM,MAUA;AACH;AACA;AACA;AACA;AACA;AAEA;AACAA,QAAI,GAAIA,IAAI,GAAG,UAAR,IAAuB,EAA9B;AACAC,QAAI,GAAI,CAACN,GAAG,CAAC,CAAD,CAAH,GAAS,UAAV,IAAwB,KAAzB,IAAmC,EAA1C;AACH;;AAED,SAAOO,IAAI,GAAGF,IAAP,GAAcC,IAAI,GAAG,MAA5B;AACH","names":["f64","Float64Array","u32","Uint32Array","buffer","uint16ToFloat64","h","expo","sigf","sign","NaN","float64ToUint16","d"],"sources":["util/math.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst f64 = new Float64Array(1);\nconst u32 = new Uint32Array(f64.buffer);\n\n/**\n * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29\n * @param h {number} the uint16 to convert\n * @private\n * @ignore\n */\nexport function uint16ToFloat64(h: number) {\n    let expo = (h & 0x7C00) >> 10;\n    let sigf = (h & 0x03FF) / 1024;\n    let sign = (-1) ** ((h & 0x8000) >> 15);\n    switch (expo) {\n        case 0x1F: return sign * (sigf ? NaN : 1 / 0);\n        case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (2 ** (expo - 15)) * (1 + sigf);\n}\n\n/**\n * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * @param d {number} The float64 to convert\n * @private\n * @ignore\n */\nexport function float64ToUint16(d: number) {\n\n    if (d !== d) { return 0x7E00; } // NaN\n\n    f64[0] = d;\n\n    // Magic numbers:\n    // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n    // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n    // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n\n    let sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n    let expo = (u32[1] & 0x7ff00000), sigf = 0x0000;\n\n    if (expo >= 0x40f00000) {\n        //\n        // If exponent overflowed, the float16 is either NaN or Infinity.\n        // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n        //\n        // Magic numbers:\n        // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n        // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n        //\n        // returns:\n        // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n        // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n        // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n        // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n        //\n        // If mantissa is greater than 23 bits, set to +Infinity like numpy\n        if (u32[0] > 0) {\n            expo = 0x7C00;\n        } else {\n            expo = (expo & 0x7C000000) >> 16;\n            sigf = (u32[1] & 0x000fffff) >> 10;\n        }\n    } else if (expo <= 0x3f000000) {\n        //\n        // If exponent underflowed, the float is either signed zero or subnormal.\n        //\n        // Magic numbers:\n        // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n        //\n        sigf = 0x100000 + (u32[1] & 0x000fffff);\n        sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n        expo = 0;\n    } else {\n        //\n        // No overflow or underflow, rebase the exponent and round the mantissa\n        // Magic numbers:\n        // 0x200 = 00000010 00000000 -- masks off the 10th bit\n        //\n\n        // Ensure the first mantissa bit (the 10th one) is 1 and round\n        expo = (expo - 0x3f000000) >> 10;\n        sigf = ((u32[1] & 0x000fffff) + 0x200) >> 10;\n    }\n\n    return sign | expo | sigf & 0xFFFF;\n}\n"]},"metadata":{},"sourceType":"module"}