{"ast":null,"code":"/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n/**\n * @typedef {number}\n */\n\nflatbuffers.Offset;\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\n\nflatbuffers.Table;\n/**\n * @type {number}\n * @const\n */\n\nflatbuffers.SIZEOF_SHORT = 2;\n/**\n * @type {number}\n * @const\n */\n\nflatbuffers.SIZEOF_INT = 4;\n/**\n * @type {number}\n * @const\n */\n\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n/**\n * @enum {number}\n */\n\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n/**\n * @type {Int32Array}\n * @const\n */\n\nflatbuffers.int32 = new Int32Array(2);\n/**\n * @type {Float32Array}\n * @const\n */\n\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n/**\n * @type {Float64Array}\n * @const\n */\n\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n/**\n * @type {boolean}\n * @const\n */\n\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1; ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\n\nflatbuffers.Long = function (low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n  /**\n   * @type {number}\n   * @const\n   */\n\n  this.high = high | 0;\n};\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\n\n\nflatbuffers.Long.create = function (low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n/**\n * @returns {number}\n */\n\n\nflatbuffers.Long.prototype.toFloat64 = function () {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\n\n\nflatbuffers.Long.prototype.equals = function (other) {\n  return this.low == other.low && this.high == other.high;\n};\n/**\n * @type {flatbuffers.Long}\n * @const\n */\n\n\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0); /// @endcond\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\n\nflatbuffers.Builder = function (opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n\n\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this.space = initial_size;\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this.minalign = 1;\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this.vtable = null;\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this.vtable_in_use = 0;\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n\n  this.isNested = false;\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this.object_start = 0;\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this.vtables = [];\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this.vector_num_elems = 0;\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function () {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\n\n\nflatbuffers.Builder.prototype.forceDefaults = function (forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\n\n\nflatbuffers.Builder.prototype.dataBuffer = function () {\n  return this.bb;\n};\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {Uint8Array}\n */\n\n\nflatbuffers.Builder.prototype.asUint8Array = function () {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n}; /// @cond FLATBUFFERS_INTERNAL\n\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\n\n\nflatbuffers.Builder.prototype.prep = function (size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  } // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n\n\n  var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1; // Reallocate the buffer if needed.\n\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n/**\n * @param {number} byte_size\n */\n\n\nflatbuffers.Builder.prototype.pad = function (byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n/**\n * @param {number} value\n */\n\n\nflatbuffers.Builder.prototype.writeInt8 = function (value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n/**\n * @param {number} value\n */\n\n\nflatbuffers.Builder.prototype.writeInt16 = function (value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n/**\n * @param {number} value\n */\n\n\nflatbuffers.Builder.prototype.writeInt32 = function (value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n/**\n * @param {flatbuffers.Long} value\n */\n\n\nflatbuffers.Builder.prototype.writeInt64 = function (value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n/**\n * @param {number} value\n */\n\n\nflatbuffers.Builder.prototype.writeFloat32 = function (value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n/**\n * @param {number} value\n */\n\n\nflatbuffers.Builder.prototype.writeFloat64 = function (value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n}; /// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addInt8 = function (value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addInt16 = function (value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addInt32 = function (value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addInt64 = function (value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addFloat32 = function (value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\n\n\nflatbuffers.Builder.prototype.addFloat64 = function (value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n}; /// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldInt8 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldInt16 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldInt32 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldInt64 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldFloat32 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldFloat64 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldOffset = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\n\n\nflatbuffers.Builder.prototype.addFieldStruct = function (voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\n\n\nflatbuffers.Builder.prototype.nested = function (obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\n\n\nflatbuffers.Builder.prototype.notNested = function () {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\n\n\nflatbuffers.Builder.prototype.slot = function (voffset) {\n  this.vtable[voffset] = this.offset();\n};\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\n\n\nflatbuffers.Builder.prototype.offset = function () {\n  return this.bb.capacity() - this.space;\n};\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\n\n\nflatbuffers.Builder.growByteBuffer = function (bb) {\n  var old_buf_size = bb.capacity(); // Ensure we don't grow beyond what fits in an int.\n\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n}; /// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\n\n\nflatbuffers.Builder.prototype.addOffset = function (offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n}; /// @cond FLATBUFFERS_INTERNAL\n\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\n\n\nflatbuffers.Builder.prototype.startObject = function (numfields) {\n  this.notNested();\n\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n\n  this.vtable_in_use = numfields;\n\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\n\n\nflatbuffers.Builder.prototype.endObject = function () {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset(); // Trim trailing zeroes.\n\n  var i = this.vtable_in_use - 1;\n\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n\n  var trimmed_size = i + 1; // Write out the current vtable.\n\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len); // Search for an existing vtable that matches the current one.\n\n  var existing_vtable = 0;\n  var vt1 = this.space;\n\n  outer_loop: for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc; // Point table to existing vtable.\n\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset()); // Point table to current vtable.\n\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n}; /// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\n\n\nflatbuffers.Builder.prototype.finish = function (root_table, opt_file_identifier) {\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH);\n\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT);\n  this.addOffset(root_table);\n  this.bb.setPosition(this.space);\n}; /// @cond FLATBUFFERS_INTERNAL\n\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\n\n\nflatbuffers.Builder.prototype.requiredField = function (table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0; // If this fails, the caller will show what field needs to be set.\n\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\n\n\nflatbuffers.Builder.prototype.startVector = function (elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\n\n\nflatbuffers.Builder.prototype.endVector = function () {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n}; /// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\n\n\nflatbuffers.Builder.prototype.createString = function (s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint; // Decode UTF-16\n\n      var a = s.charCodeAt(i++);\n\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      } // Encode UTF-8\n\n\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(codePoint >> 6 & 0x1F | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(codePoint >> 12 & 0x0F | 0xE0);\n          } else {\n            utf8.push(codePoint >> 18 & 0x07 | 0xF0, codePoint >> 12 & 0x3F | 0x80);\n          }\n\n          utf8.push(codePoint >> 6 & 0x3F | 0x80);\n        }\n\n        utf8.push(codePoint & 0x3F | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n\n  return this.endVector();\n};\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\n\n\nflatbuffers.Builder.prototype.createLong = function (low, high) {\n  return flatbuffers.Long.create(low, high);\n}; ////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\n\n\nflatbuffers.ByteBuffer = function (bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.position_ = 0;\n};\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {flatbuffers.ByteBuffer}\n */\n\n\nflatbuffers.ByteBuffer.allocate = function (byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function () {\n  this.position_ = 0;\n};\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\n\n\nflatbuffers.ByteBuffer.prototype.bytes = function () {\n  return this.bytes_;\n};\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.position = function () {\n  return this.position_;\n};\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\n\n\nflatbuffers.ByteBuffer.prototype.setPosition = function (position) {\n  this.position_ = position;\n};\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.capacity = function () {\n  return this.bytes_.length;\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readInt8 = function (offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readUint8 = function (offset) {\n  return this.bytes_[offset];\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readInt16 = function (offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readUint16 = function (offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readInt32 = function (offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readUint32 = function (offset) {\n  return this.readInt32(offset) >>> 0;\n};\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readInt64 = function (offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readUint64 = function (offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readFloat32 = function (offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n/**\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.readFloat64 = function (offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeInt8 = function (offset, value) {\n  this.bytes_[offset] =\n  /** @type {number} */\n  value;\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeUint8 = function (offset, value) {\n  this.bytes_[offset] = value;\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeInt16 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeUint16 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeInt32 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeUint32 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeInt64 = function (offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeUint64 = function (offset, value) {\n  this.writeUint32(offset, value.low);\n  this.writeUint32(offset + 4, value.high);\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function (offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n/**\n * @param {number} offset\n * @param {number} value\n */\n\n\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function (offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\n\n\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function () {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n\n  var result = \"\";\n\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n\n  return result;\n};\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__offset = function (bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__union = function (t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|Uint8Array}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__string = function (offset, opt_encoding) {\n  offset += this.readInt32(offset);\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint; // Decode UTF-8\n\n    var a = this.readUint8(offset + i++);\n\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n\n      if (a < 0xE0) {\n        codePoint = (a & 0x1F) << 6 | b & 0x3F;\n      } else {\n        var c = this.readUint8(offset + i++);\n\n        if (a < 0xF0) {\n          codePoint = (a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F;\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint = (a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F;\n        }\n      }\n    } // Encode UTF-16\n\n\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & (1 << 10) - 1) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__indirect = function (offset) {\n  return offset + this.readInt32(offset);\n};\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__vector = function (offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__vector_len = function (offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n/**\n * @param {string} ident\n * @returns {boolean}\n */\n\n\nflatbuffers.ByteBuffer.prototype.__has_identifier = function (ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\n\n\nflatbuffers.ByteBuffer.prototype.createLong = function (low, high) {\n  return flatbuffers.Long.create(low, high);\n}; // Exports for Node.js and RequireJS\n\n\nexport { flatbuffers }; /// @endcond\n/// @}","map":{"version":3,"sources":["/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/flatbuffers/js/flatbuffers.mjs"],"names":["flatbuffers","Offset","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","int32","Int32Array","float32","Float32Array","buffer","float64","Float64Array","isLittleEndian","Uint16Array","Uint8Array","Long","low","high","create","ZERO","prototype","toFloat64","equals","other","Builder","opt_initial_size","initial_size","bb","ByteBuffer","allocate","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","size","additional_bytes","align_size","old_buf_size","growByteBuffer","pad","byte_size","i","writeInt8","value","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","voffset","defaultValue","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","obj","Error","notNested","new_buf_size","nbb","setPosition","set","startObject","numfields","endObject","vtableloc","trimmed_size","standard_fields","len","existing_vtable","vt1","outer_loop","length","vt2","readInt16","j","push","finish","root_table","opt_file_identifier","file_identifier","charCodeAt","requiredField","table","field","table_start","vtable_start","readInt32","ok","startVector","elem_size","num_elems","alignment","endVector","createString","s","utf8","codePoint","a","b","createLong","bytes_","position_","readInt8","readUint8","readUint16","readUint32","readInt64","readUint64","readFloat32","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","result","String","fromCharCode","__offset","bb_pos","vtable_offset","__union","t","__string","opt_encoding","c","d","__indirect","__vector","__vector_len","__has_identifier","ident"],"mappings":"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","sourcesContent":["/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier) {\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT);\n  this.addOffset(root_table);\n  this.bb.setPosition(this.space);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n"]},"metadata":{},"sourceType":"module"}