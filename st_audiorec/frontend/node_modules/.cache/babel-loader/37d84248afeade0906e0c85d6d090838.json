{"ast":null,"code":"import _regeneratorRuntime from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _inherits from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/louiskrause/neuefische/RespiratoryApp/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport streamAdapters from './adapters';\n/** @ignore */\n\nexport var ITERATOR_DONE = Object.freeze({\n  done: true,\n  value: void 0\n});\n/** @ignore */\n\nexport var ArrowJSON = /*#__PURE__*/function () {\n  // @ts-ignore\n  function ArrowJSON(_json) {\n    _classCallCheck(this, ArrowJSON);\n\n    this._json = _json;\n  }\n\n  _createClass(ArrowJSON, [{\n    key: \"schema\",\n    get: function get() {\n      return this._json['schema'];\n    }\n  }, {\n    key: \"batches\",\n    get: function get() {\n      return this._json['batches'] || [];\n    }\n  }, {\n    key: \"dictionaries\",\n    get: function get() {\n      return this._json['dictionaries'] || [];\n    }\n  }]);\n\n  return ArrowJSON;\n}();\n/** @ignore */\n\nexport var ReadableInterop = /*#__PURE__*/function () {\n  function ReadableInterop() {\n    _classCallCheck(this, ReadableInterop);\n  }\n\n  _createClass(ReadableInterop, [{\n    key: \"tee\",\n    value: function tee() {\n      return this._getDOMStream().tee();\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(writable, options) {\n      return this._getNodeStream().pipe(writable, options);\n    }\n  }, {\n    key: \"pipeTo\",\n    value: function pipeTo(writable, options) {\n      return this._getDOMStream().pipeTo(writable, options);\n    }\n  }, {\n    key: \"pipeThrough\",\n    value: function pipeThrough(duplex, options) {\n      return this._getDOMStream().pipeThrough(duplex, options);\n    }\n  }, {\n    key: \"_getDOMStream\",\n    value: function _getDOMStream() {\n      return this._DOMStream || (this._DOMStream = this.toDOMStream());\n    }\n  }, {\n    key: \"_getNodeStream\",\n    value: function _getNodeStream() {\n      return this._nodeStream || (this._nodeStream = this.toNodeStream());\n    }\n  }]);\n\n  return ReadableInterop;\n}();\n/** @ignore */\n\nexport var AsyncQueue = /*#__PURE__*/function (_ReadableInterop, _Symbol$asyncIterator) {\n  _inherits(AsyncQueue, _ReadableInterop);\n\n  var _super = _createSuper(AsyncQueue);\n\n  function AsyncQueue() {\n    var _this;\n\n    _classCallCheck(this, AsyncQueue);\n\n    _this = _super.call(this);\n    _this._values = [];\n    _this.resolvers = [];\n    _this._closedPromise = new Promise(function (r) {\n      return _this._closedPromiseResolve = r;\n    });\n    return _this;\n  }\n\n  _createClass(AsyncQueue, [{\n    key: \"closed\",\n    get: function get() {\n      return this._closedPromise;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(reason) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.return(reason);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function cancel(_x) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: \"write\",\n    value: function write(value) {\n      if (this._ensureOpen()) {\n        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({\n          done: false,\n          value: value\n        });\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(value) {\n      if (this._closedPromiseResolve) {\n        this.resolvers.length <= 0 ? this._error = {\n          error: value\n        } : this.resolvers.shift().reject({\n          done: true,\n          value: value\n        });\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._closedPromiseResolve) {\n        var resolvers = this.resolvers;\n\n        while (resolvers.length > 0) {\n          resolvers.shift().resolve(ITERATOR_DONE);\n        }\n\n        this._closedPromiseResolve();\n\n        this._closedPromiseResolve = undefined;\n      }\n    }\n  }, {\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      return this;\n    }\n  }, {\n    key: \"toDOMStream\",\n    value: function toDOMStream(options) {\n      return streamAdapters.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n    }\n  }, {\n    key: \"toNodeStream\",\n    value: function toNodeStream(options) {\n      return streamAdapters.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n    }\n  }, {\n    key: \"throw\",\n    value: function () {\n      var _throw2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.abort(_);\n\n              case 2:\n                return _context2.abrupt(\"return\", ITERATOR_DONE);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _throw(_x2) {\n        return _throw2.apply(this, arguments);\n      }\n\n      return _throw;\n    }()\n  }, {\n    key: \"return\",\n    value: function () {\n      var _return2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.close();\n\n              case 2:\n                return _context3.abrupt(\"return\", ITERATOR_DONE);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _return(_x3) {\n        return _return2.apply(this, arguments);\n      }\n\n      return _return;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(size) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.next(size, 'read');\n\n              case 2:\n                return _context4.abrupt(\"return\", _context4.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function read(_x4) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"peek\",\n    value: function () {\n      var _peek = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(size) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.next(size, 'peek');\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function peek(_x5) {\n        return _peek.apply(this, arguments);\n      }\n\n      return peek;\n    }()\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this2 = this;\n\n      if (this._values.length > 0) {\n        return Promise.resolve({\n          done: false,\n          value: this._values.shift()\n        });\n      } else if (this._error) {\n        return Promise.reject({\n          done: true,\n          value: this._error.error\n        });\n      } else if (!this._closedPromiseResolve) {\n        return Promise.resolve(ITERATOR_DONE);\n      } else {\n        return new Promise(function (resolve, reject) {\n          _this2.resolvers.push({\n            resolve: resolve,\n            reject: reject\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_ensureOpen\",\n    value: function _ensureOpen() {\n      if (this._closedPromiseResolve) {\n        return true;\n      }\n\n      throw new Error(\"\".concat(this, \" is closed\"));\n    }\n  }]);\n\n  return AsyncQueue;\n}(ReadableInterop, Symbol.asyncIterator);","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,YAA3B;AAEA;;AACA,OAAO,IAAMC,aAAa,GAAQC,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAI,EAAE,IAAR;AAAcC,OAAK,EAAE,KAAM;AAA3B,CAAd,CAA3B;AASP;;AACA,WAAaC,SAAb;AACI;AACA,qBAAoBC,KAApB,EAAwC;AAAA;;AAApB;AAAwB;;AAFhD;AAAA;AAAA,SAGI,eAAiB;AAAU,aAAO,KAAKA,KAAL,CAAW,QAAX,CAAP;AAA8B;AAH7D;AAAA;AAAA,SAII,eAAkB;AAAY,aAAQ,KAAKA,KAAL,CAAW,SAAX,KAAyB,EAAjC;AAAgD;AAJlF;AAAA;AAAA,SAKI,eAAuB;AAAY,aAAQ,KAAKA,KAAL,CAAW,cAAX,KAA8B,EAAtC;AAAqD;AAL5F;;AAAA;AAAA;AAoCA;;AACA,WAAsBC,eAAtB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,WAKW,eAAG;AACN,aAAO,KAAKC,aAAL,GAAqBC,GAArB,EAAP;AACH;AAPL;AAAA;AAAA,WAQW,cAAsCC,QAAtC,EAAmDC,OAAnD,EAA+E;AAClF,aAAO,KAAKC,cAAL,GAAsBC,IAAtB,CAA2BH,QAA3B,EAAqCC,OAArC,CAAP;AACH;AAVL;AAAA;AAAA,WAWW,gBAAOD,QAAP,EAAoCC,OAApC,EAAyD;AAAI,aAAO,KAAKH,aAAL,GAAqBM,MAArB,CAA4BJ,QAA5B,EAAsCC,OAAtC,CAAP;AAAwD;AAXhI;AAAA;AAAA,WAYW,qBAA2CI,MAA3C,EAAiGJ,OAAjG,EAAsH;AACzH,aAAO,KAAKH,aAAL,GAAqBQ,WAArB,CAAiCD,MAAjC,EAAyCJ,OAAzC,CAAP;AACH;AAdL;AAAA;AAAA,WAiBY,yBAAa;AACjB,aAAO,KAAKM,UAAL,KAAoB,KAAKA,UAAL,GAAkB,KAAKC,WAAL,EAAtC,CAAP;AACH;AAnBL;AAAA;AAAA,WAsBY,0BAAc;AAClB,aAAO,KAAKC,WAAL,KAAqB,KAAKA,WAAL,GAAmB,KAAKC,YAAL,EAAxC,CAAP;AACH;AAxBL;;AAAA;AAAA;AA8BA;;AACA,WAAaC,UAAb;AAAA;;AAAA;;AASI;AAAA;;AAAA;;AACI;AAPM,oBAAuB,EAAvB;AAIA,sBAAqD,EAArD;AAIN,UAAKC,cAAL,GAAsB,IAAIC,OAAJ,CAAY,UAACC,CAAD;AAAA,aAAO,MAAKC,qBAAL,GAA6BD,CAApC;AAAA,KAAZ,CAAtB;AAFJ;AAGC;;AAZL;AAAA;AAAA,SAcI,eAAiB;AAAoB,aAAO,KAAKF,cAAZ;AAA6B;AAdtE;AAAA;AAAA;AAAA,6EAeW,iBAAaI,MAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAmC,KAAKC,MAAL,CAAYD,MAAZ,CAAnC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAfX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WAgBW,eAAMtB,KAAN,EAAsB;AACzB,UAAI,KAAKwB,WAAL,EAAJ,EAAwB;AACpB,aAAKC,SAAL,CAAeC,MAAf,IAAyB,CAAzB,GACO,KAAKC,OAAL,CAAaC,IAAb,CAAkB5B,KAAlB,CADP,GAEO,KAAKyB,SAAL,CAAeI,KAAf,GAAwBC,OAAxB,CAAgC;AAAE/B,cAAI,EAAE,KAAR;AAAeC,eAAK,EAALA;AAAf,SAAhC,CAFP;AAGH;AACJ;AAtBL;AAAA;AAAA,WAuBW,eAAMA,KAAN,EAAiB;AACpB,UAAI,KAAKqB,qBAAT,EAAgC;AAC5B,aAAKI,SAAL,CAAeC,MAAf,IAAyB,CAAzB,GACO,KAAKK,MAAL,GAAc;AAAEC,eAAK,EAAEhC;AAAT,SADrB,GAEO,KAAKyB,SAAL,CAAeI,KAAf,GAAwBI,MAAxB,CAA+B;AAAElC,cAAI,EAAE,IAAR;AAAcC,eAAK,EAALA;AAAd,SAA/B,CAFP;AAGH;AACJ;AA7BL;AAAA;AAAA,WA8BW,iBAAK;AACR,UAAI,KAAKqB,qBAAT,EAAgC;AAC5B,YAAQI,SAAR,GAAsB,IAAtB,CAAQA,SAAR;;AACA,eAAOA,SAAS,CAACC,MAAV,GAAmB,CAA1B,EAA6B;AACzBD,mBAAS,CAACI,KAAV,GAAmBC,OAAnB,CAA2BlC,aAA3B;AACH;;AACD,aAAKyB,qBAAL;;AACA,aAAKA,qBAAL,GAA6Ba,SAA7B;AACH;AACJ;AAvCL;AAAA;AAAA,WAyCW,iBAAsB;AAAK,aAAO,IAAP;AAAc;AAzCpD;AAAA;AAAA,WA0CW,qBAAY3B,OAAZ,EAA8C;AACjD,aAAOZ,cAAc,CAACmB,WAAf,CACF,KAAKO,qBAAL,IAA8B,KAAKU,MAApC,GACO,IADP,GAEO,KAAKJ,OAHT,EAIHpB,OAJG,CAAP;AAKH;AAhDL;AAAA;AAAA,WAiDW,sBAAaA,OAAb,EAAuD;AAC1D,aAAOZ,cAAc,CAACqB,YAAf,CACF,KAAKK,qBAAL,IAA8B,KAAKU,MAApC,GACO,IADP,GAEO,KAAKJ,OAHT,EAIHpB,OAJG,CAAP;AAKH;AAvDL;AAAA;AAAA;AAAA,6EAwDW,kBAAY4B,CAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA6B,KAAKC,KAAL,CAAWD,CAAX,CAA7B;;AAAA;AAAA,kDAAmDvC,aAAnD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAxDX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8EAyDW,kBAAauC,CAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA8B,KAAKE,KAAL,EAA9B;;AAAA;AAAA,kDAAmDzC,aAAnD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAzDX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2EA2DW,kBAAW0C,IAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA4E,KAAKC,IAAL,CAAUD,IAAV,EAAgB,MAAhB,CAA5E;;AAAA;AAAA,iEAAqGtC,KAArG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA3DX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2EA4DW,kBAAWsC,IAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA4E,KAAKC,IAAL,CAAUD,IAAV,EAAgB,MAAhB,CAA5E;;AAAA;AAAA,iEAAqGtC,KAArG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA5DX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WA6DW,gBAAoB;AAAA;;AACvB,UAAI,KAAK2B,OAAL,CAAaD,MAAb,GAAsB,CAA1B,EAA6B;AACzB,eAAOP,OAAO,CAACW,OAAR,CAAgB;AAAE/B,cAAI,EAAE,KAAR;AAAeC,eAAK,EAAE,KAAK2B,OAAL,CAAaE,KAAb;AAAtB,SAAhB,CAAP;AACH,OAFD,MAEO,IAAI,KAAKE,MAAT,EAAiB;AACpB,eAAOZ,OAAO,CAACc,MAAR,CAAe;AAAElC,cAAI,EAAE,IAAR;AAAcC,eAAK,EAAE,KAAK+B,MAAL,CAAYC;AAAjC,SAAf,CAAP;AACH,OAFM,MAEA,IAAI,CAAC,KAAKX,qBAAV,EAAiC;AACpC,eAAOF,OAAO,CAACW,OAAR,CAAgBlC,aAAhB,CAAP;AACH,OAFM,MAEA;AACH,eAAO,IAAIuB,OAAJ,CAAuC,UAACW,OAAD,EAAUG,MAAV,EAAoB;AAC9D,gBAAI,CAACR,SAAL,CAAeG,IAAf,CAAoB;AAAEE,mBAAO,EAAPA,OAAF;AAAWG,kBAAM,EAANA;AAAX,WAApB;AACH,SAFM,CAAP;AAGH;AACJ;AAzEL;AAAA;AAAA,WA2Ec,uBAAW;AACjB,UAAI,KAAKZ,qBAAT,EAAgC;AAC5B,eAAO,IAAP;AACH;;AACD,YAAM,IAAImB,KAAJ,WAAa,IAAb,gBAAN;AACH;AAhFL;;AAAA;AAAA,EAA+ErC,eAA/E,EAyCYsC,MAAM,CAACC,aAzCnB","names":["streamAdapters","ITERATOR_DONE","Object","freeze","done","value","ArrowJSON","_json","ReadableInterop","_getDOMStream","tee","writable","options","_getNodeStream","pipe","pipeTo","duplex","pipeThrough","_DOMStream","toDOMStream","_nodeStream","toNodeStream","AsyncQueue","_closedPromise","Promise","r","_closedPromiseResolve","reason","return","_ensureOpen","resolvers","length","_values","push","shift","resolve","_error","error","reject","undefined","_","abort","close","size","next","Error","Symbol","asyncIterator"],"sources":["io/interfaces.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport streamAdapters from './adapters';\n\n/** @ignore */\nexport const ITERATOR_DONE: any = Object.freeze({ done: true, value: void (0) });\n\n/** @ignore */\nexport type FileHandle = import('fs').promises.FileHandle;\n/** @ignore */\nexport type ArrowJSONLike = { schema: any; batches?: any[]; dictionaries?: any[]; };\n/** @ignore */\nexport type ReadableDOMStreamOptions = { type: 'bytes' | undefined, autoAllocateChunkSize?: number, highWaterMark?: number };\n\n/** @ignore */\nexport class ArrowJSON {\n    // @ts-ignore\n    constructor(private _json: ArrowJSONLike) {}\n    public get schema(): any { return this._json['schema']; }\n    public get batches(): any[] { return (this._json['batches'] || []) as any[]; }\n    public get dictionaries(): any[] { return (this._json['dictionaries'] || []) as any[]; }\n}\n\n/** @ignore */\nexport interface Readable<T> {\n\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n\n    read(size?: number | null): Promise<T | null>;\n    peek(size?: number | null): Promise<T | null>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(size?: number | null): Promise<IteratorResult<T>>;\n}\n\n/** @ignore */\nexport interface Writable<T> {\n    readonly closed: Promise<void>;\n    close(): void;\n    write(chunk: T): void;\n    abort(reason?: any): void;\n}\n\n/** @ignore */\nexport interface ReadableWritable<TReadable, TWritable> extends Readable<TReadable>, Writable<TWritable> {\n    [Symbol.asyncIterator](): AsyncIterableIterator<TReadable>;\n    toDOMStream(options?: ReadableDOMStreamOptions): ReadableStream<TReadable>;\n    toNodeStream(options?: import('stream').ReadableOptions): import('stream').Readable;\n}\n\n/** @ignore */\nexport abstract class ReadableInterop<T> {\n\n    public abstract toDOMStream(options?: ReadableDOMStreamOptions): ReadableStream<T>;\n    public abstract toNodeStream(options?: import('stream').ReadableOptions): import('stream').Readable;\n\n    public tee(): [ReadableStream<T>, ReadableStream<T>] {\n        return this._getDOMStream().tee();\n    }\n    public pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean; }) {\n        return this._getNodeStream().pipe(writable, options);\n    }\n    public pipeTo(writable: WritableStream<T>, options?: PipeOptions) { return this._getDOMStream().pipeTo(writable, options); }\n    public pipeThrough<R extends ReadableStream<any>>(duplex: { writable: WritableStream<T>, readable: R }, options?: PipeOptions) {\n        return this._getDOMStream().pipeThrough(duplex, options);\n    }\n\n    protected _DOMStream?: ReadableStream<T>;\n    private _getDOMStream() {\n        return this._DOMStream || (this._DOMStream = this.toDOMStream());\n    }\n\n    protected _nodeStream?: import('stream').Readable;\n    private _getNodeStream() {\n        return this._nodeStream || (this._nodeStream = this.toNodeStream());\n    }\n}\n\n/** @ignore */\ntype Resolution<T> = { resolve: (value?: T | PromiseLike<T>) => void; reject: (reason?: any) => void; };\n\n/** @ignore */\nexport class AsyncQueue<TReadable = Uint8Array, TWritable = TReadable> extends ReadableInterop<TReadable>\n    implements AsyncIterableIterator<TReadable>, ReadableWritable<TReadable, TWritable> {\n\n    protected _values: TWritable[] = [];\n    protected _error?: { error: any; };\n    protected _closedPromise: Promise<void>;\n    protected _closedPromiseResolve?: (value?: any) => void;\n    protected resolvers: Resolution<IteratorResult<TReadable>>[] = [];\n\n    constructor() {\n        super();\n        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n    }\n\n    public get closed(): Promise<void> { return this._closedPromise; }\n    public async cancel(reason?: any) { await this.return(reason); }\n    public write(value: TWritable) {\n        if (this._ensureOpen()) {\n            this.resolvers.length <= 0\n                ? (this._values.push(value))\n                : (this.resolvers.shift()!.resolve({ done: false, value } as any));\n        }\n    }\n    public abort(value?: any) {\n        if (this._closedPromiseResolve) {\n            this.resolvers.length <= 0\n                ? (this._error = { error: value })\n                : (this.resolvers.shift()!.reject({ done: true, value }));\n        }\n    }\n    public close() {\n        if (this._closedPromiseResolve) {\n            const { resolvers } = this;\n            while (resolvers.length > 0) {\n                resolvers.shift()!.resolve(ITERATOR_DONE);\n            }\n            this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n        }\n    }\n\n    public [Symbol.asyncIterator]() { return this; }\n    public toDOMStream(options?: ReadableDOMStreamOptions) {\n        return streamAdapters.toDOMStream(\n            (this._closedPromiseResolve || this._error)\n                ? (this as AsyncIterable<TReadable>)\n                : (this._values as any) as Iterable<TReadable>,\n            options);\n    }\n    public toNodeStream(options?: import('stream').ReadableOptions) {\n        return streamAdapters.toNodeStream(\n            (this._closedPromiseResolve || this._error)\n                ? (this as AsyncIterable<TReadable>)\n                : (this._values as any) as Iterable<TReadable>,\n            options);\n    }\n    public async throw(_?: any) { await this.abort(_); return ITERATOR_DONE; }\n    public async return(_?: any) { await this.close(); return ITERATOR_DONE; }\n\n    public async read(size?: number | null): Promise<TReadable | null> { return (await this.next(size, 'read')).value; }\n    public async peek(size?: number | null): Promise<TReadable | null> { return (await this.next(size, 'peek')).value; }\n    public next(..._args: any[]): Promise<IteratorResult<TReadable>> {\n        if (this._values.length > 0) {\n            return Promise.resolve({ done: false, value: this._values.shift()! } as any);\n        } else if (this._error) {\n            return Promise.reject({ done: true, value: this._error.error });\n        } else if (!this._closedPromiseResolve) {\n            return Promise.resolve(ITERATOR_DONE);\n        } else {\n            return new Promise<IteratorResult<TReadable>>((resolve, reject) => {\n                this.resolvers.push({ resolve, reject });\n            });\n        }\n    }\n\n    protected _ensureOpen() {\n        if (this._closedPromiseResolve) {\n            return true;\n        }\n        throw new Error(`${this} is closed`);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}